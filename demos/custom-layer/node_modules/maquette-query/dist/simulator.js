(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let createEvent = (target) => {
        let result = {
            defaultPrevented: false,
            propagationStopped: false,
            preventDefault: () => {
                result.defaultPrevented = true;
            },
            stopPropagation: () => {
                result.propagationStopped = true;
            },
            target,
            currentTarget: target
        };
        return result;
    };
    let createKeyEvent = (which, target) => {
        let event = createEvent(target);
        event.which = which;
        event.keyCode = which;
        return event;
    };
    let createMouseEvent = (target, parameters) => {
        let event = createEvent(target);
        if (parameters) {
            Object.keys(parameters).forEach(param => { event[param] = parameters[param]; });
        }
        return event;
    };
    let createFocusEvent = (target) => {
        return createEvent(target);
    };
    let getKeyCode = (keyCodeOrChar) => {
        return typeof keyCodeOrChar === 'number' ? keyCodeOrChar : keyCodeOrChar.charCodeAt(0);
    };
    exports.createSimulator = (vnode, defaultFakeDomNode) => {
        let properties = vnode.properties;
        return {
            keyDown: (keyCode, fakeDomNode) => {
                let event = createKeyEvent(getKeyCode(keyCode), fakeDomNode || defaultFakeDomNode);
                properties.onkeydown.call(properties.bind || properties, event);
                return event;
            },
            keyUp: (keyCode, fakeDomNode) => {
                let event = createKeyEvent(getKeyCode(keyCode), fakeDomNode || defaultFakeDomNode);
                properties.onkeyup.call(properties.bind || properties, event);
                return event;
            },
            mouseDown: (fakeDomNode, parameters) => {
                let event = createMouseEvent(fakeDomNode || defaultFakeDomNode, parameters);
                properties.onmousedown.call(properties.bind || properties, event);
                return event;
            },
            mouseUp: (fakeDomNode, parameters) => {
                let event = createMouseEvent(fakeDomNode || defaultFakeDomNode, parameters);
                properties.onmouseup.call(properties.bind || properties, event);
                return event;
            },
            mouseOver: (fakeDomNode, parameters) => {
                let event = createMouseEvent(fakeDomNode || defaultFakeDomNode, parameters);
                properties.onmouseover.call(properties.bind || properties, event);
                return event;
            },
            mouseOut: (fakeDomNode, parameters) => {
                let event = createMouseEvent(fakeDomNode || defaultFakeDomNode, parameters);
                properties.onmouseout.call(properties.bind || properties, event);
                return event;
            },
            click: (fakeDomNode, parameters) => {
                let event = createMouseEvent(fakeDomNode || defaultFakeDomNode, parameters);
                properties.onclick.call(properties.bind || properties, event);
                return event;
            },
            input: (fakeDomNode) => {
                let event = createEvent(fakeDomNode || defaultFakeDomNode);
                properties.oninput.call(properties.bind || properties, event);
                return event;
            },
            change: (fakeDomNode) => {
                let event = createEvent(fakeDomNode || defaultFakeDomNode);
                properties.onchange.call(properties.bind || properties, event);
                return event;
            },
            focus: (fakeDomNode) => {
                let event = createFocusEvent(fakeDomNode || defaultFakeDomNode);
                properties.onfocus.call(properties.bind || properties, event);
                return event;
            },
            blur: (fakeDomNode) => {
                let event = createFocusEvent(fakeDomNode || defaultFakeDomNode);
                properties.onblur.call(properties.bind || properties, event);
                return event;
            },
            keyPress: (keyCodeOrChar, valueBefore, valueAfter, fakeDomNode) => {
                let target = (fakeDomNode || defaultFakeDomNode || {});
                let keyCode = typeof keyCodeOrChar === 'number' ? keyCodeOrChar : keyCodeOrChar.charCodeAt(0);
                target.value = valueBefore;
                let keyDownEvent = createKeyEvent(keyCode, target);
                if (properties.onkeydown) {
                    properties.onkeydown.call(properties.bind || properties, keyDownEvent);
                }
                if (!keyDownEvent.defaultPrevented) {
                    target.value = valueAfter;
                    if (properties.oninput) {
                        properties.oninput.call(properties.bind || properties, createEvent(target));
                    }
                }
                if (properties.onkeyup) {
                    properties.onkeyup.call(properties.bind || properties, createKeyEvent(keyCode, target));
                }
            },
            mouseWheel: (deltas, fakeDomNode) => {
                let event = createEvent(fakeDomNode || defaultFakeDomNode);
                event.deltaX = deltas.deltaX;
                event.deltaY = deltas.deltaY;
                properties.onmousewheel.call(properties.bind || properties, event);
                return event;
            }
        };
    };
});
//# sourceMappingURL=simulator.js.map