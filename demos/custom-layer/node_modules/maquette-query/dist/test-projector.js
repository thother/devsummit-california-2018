(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./simulator"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const simulator_1 = require("./simulator");
    // Helper functions
    // ----------------
    let makeSelectorFunction = (selector) => {
        if (typeof selector === 'string') {
            return (vNode) => {
                let index = vNode.vnodeSelector.indexOf(selector);
                if ((selector[0] === '.' || selector[0] === '#') ? (index > 0) : (index === 0)) {
                    let nextChar = vNode.vnodeSelector.charAt(index + selector.length);
                    return !nextChar || nextChar === '.' || nextChar === '#';
                }
                return false;
            };
        }
        else if (typeof selector === 'function') {
            return selector;
        }
        else {
            throw new Error('Invalid selector ' + selector);
        }
    };
    let filterDescendants = (root, predicate) => {
        let results = [];
        let visit = (vnodeTree) => {
            if (vnodeTree.children) {
                vnodeTree.children.forEach((child) => {
                    if (predicate(child)) {
                        results.push(child);
                    }
                    visit(child);
                });
            }
        };
        if (root) {
            visit(root);
        }
        return results;
    };
    let collectTextContent = (vnodeTree, results) => {
        if (vnodeTree.vnodeSelector === '') {
            results.push(vnodeTree.text);
        }
        else {
            if (vnodeTree.text) {
                results.push(vnodeTree.text);
            }
            if (vnodeTree.children) {
                vnodeTree.children.forEach((child) => {
                    collectTextContent(child, results);
                });
            }
        }
        return results;
    };
    // The create methods
    let createCollectionQuery;
    let createQuery = (getVNode, getDebugInfo) => {
        let query = (selector, fakeDomNode) => {
            let predicate = makeSelectorFunction(selector);
            return createQuery(() => filterDescendants(getVNode(), predicate)[0], () => [...getDebugInfo(), selector]);
        };
        let queryAll = (selector) => {
            let predicate = makeSelectorFunction(selector);
            return createCollectionQuery(() => filterDescendants(getVNode(), predicate), () => [...getDebugInfo(), selector]);
        };
        let getResult = () => {
            let result = getVNode();
            if (!result) {
                throw new Error('Query did not match a VNode: ' + JSON.stringify(getDebugInfo(), undefined, 2));
            }
            return result;
        };
        let targetDomNode;
        return {
            debug: () => JSON.stringify(getDebugInfo()),
            execute: getResult,
            exists: () => !!getVNode(),
            query,
            queryAll,
            get textContent() {
                return collectTextContent(getResult(), []).join('');
            },
            get vnodeSelector() {
                return getResult().vnodeSelector;
            },
            get properties() {
                return getResult().properties || {};
            },
            get children() {
                return getResult().children || [];
            },
            getChild: (index) => {
                return createQuery(() => {
                    return getResult().children[index];
                }, () => [...getDebugInfo(), 'child:' + index]);
            },
            /**
             * A small facade that allows firing of simple events and sequences of events for common usecases.
             * It is not meant to be exhaustive.
             * If you need to simulate something that is not in here, you can simply invoke query(...).properties.on???() yourself.
             */
            get simulate() { return simulator_1.createSimulator(getResult(), targetDomNode); },
            setTargetDomNode: (target) => {
                targetDomNode = target;
            },
            getTargetDomNode: () => {
                return targetDomNode;
            }
        };
    };
    createCollectionQuery = (getVNodes, getDebugInfo) => {
        return {
            execute: getVNodes,
            getResult: (index) => {
                return createQuery(() => {
                    return getVNodes()[index];
                }, () => [...getDebugInfo(), 'result:' + index]);
            },
            get length() {
                return getVNodes().length;
            }
        };
    };
    /**
     * Creates a test projector which implements the QueryBase interface
     * @param renderMaquetteFunction  Optional, the renderMaquette function that is used to produce the VNode tree.
     *                                when not specified, you must use the initialize function to supply the renderMaquetteFunction.
     */
    exports.createTestProjector = (renderMaquetteFunction) => {
        let getRootVNode = () => {
            if (!renderMaquetteFunction) {
                throw new Error('TestProjector is not initialized');
            }
            return renderMaquetteFunction();
        };
        let createQueryStart = createQuery(() => {
            return {
                children: [getRootVNode()]
            };
        }, () => [getRootVNode()]);
        return {
            initialize: (initializeRenderMaquetteFunction) => {
                renderMaquetteFunction = initializeRenderMaquetteFunction;
            },
            uninitialize: () => {
                renderMaquetteFunction = undefined;
            },
            root: createQuery(getRootVNode, () => [getRootVNode()]),
            query: createQueryStart.query,
            queryAll: createQueryStart.queryAll
        };
    };
});
//# sourceMappingURL=test-projector.js.map